import sys
sys.path.append("/home/andy/Documents/Cryptography/cryptopals")

from set1.challenge8 import chunks
from set2.challenge09v2 import pad_pkcs7

""" 

    Again, we append our system path for picking up modules from 
    set1 and set2 directories. If this is similar to your own set up,
    make sure there are __init__.py files in your directories.

"""

from Crypto.Cipher import AES

from os import urandom

from random import randint, choice
from typing import Callable

TypeOracle = Callable[[bytes], bytes]

""" 

    This specifies a callable type that takes a single parameter [bytes]
    and returns a value of bytes. This is a convenient way to construct a 
    type alias that represents the type of functions that can be used
    as encryption oracles. 

"""

BLOCK_SIZE = AES.block_size  # 16 bytes
KEY_SIZE = 16

def get_oracle() -> tuple[str, TypeOracle]:
    mode = choice(("ECB", "CBC"))

    def enc_oracle(plaintext: bytes) -> bytes:
        key = urandom(KEY_SIZE)
        pre = urandom(randint(5, 10))
        post = urandom(randint(5, 10))
        plaintext = pad_pkcs7(pre + plaintext + post, BLOCK_SIZE)

        if mode == "ECB":
            cipher = AES.new(key, AES.MODE_ECB)
        else:
            iv = urandom(BLOCK_SIZE)
            cipher = AES.new(key, AES.MODE_CBC, iv)
        return cipher.encrypt(plaintext)

    return mode, enc_oracle

    """ 

        Randomly choose between CBC and ECB mode. enc_oracle() takes plaintext
        as input. We use urandom to generate a random key of 16 bytes, a random
        prefix between 5 and 10 bytes, and a random suffix between 5 and 10 bytes.
        Then, concatenate prefix, plaintext, and suffix and pad it to a multiple 
        of the BLOCK_SIZE, which is 16 bytes. 

        Depending on which mode of operation was chosen in get_oracle() function, a
        cipher object is instantiated. If ECB, it uses the key only. If CBC, it uses
        the key and the IV.

        Finally, the encrypted text in the chosen mode is generated by the encrypt 
        function.

    """


def detect(func: TypeOracle) -> str:
    plaintext = bytes(2*BLOCK_SIZE + (BLOCK_SIZE - 5))
    ciphertext = func(plaintext)
    ct_blocks = chunks(ciphertext, BLOCK_SIZE)
    if ct_blocks[1] == ct_blocks[2]:
        return "ECB"
    else:
        return "CBC"

    """ 

        Plaintext is generated as null bytes with a length of 43 bytes because 
        43 = 2*16 + (16 - 5). ciphertext is generated from oracle function.
        You can change this to a value as long as it is at least 3 blocks long.
        I chose 43 because pre and postfix will add at least 10 bytes anyway. 

        Ciphertext is split into 16 byte blocks using chunks() function. If
        the second and third blocks are equal, it indicates ECB mode was used.
        If they're not equal, it suggests CBC mode was used. We return the mode
        that was detected. 

    """


if __name__ == '__main__':
    for i, _ in enumerate(range(50), start=1):
        _mode, oracle = get_oracle()

        """ 

            _mode is used to indicate that the variable is "private" within
            the function, and does not have the same usage as the mode variable
            outside of this specific function's scope. 

        """
        guess = detect(oracle)
        print(f"#{i}:    Actual Mode: {_mode},  Guessed Mode: {guess}")
        if _mode != guess:
            raise Exception("WRONGGGG")

    print("SUCCESS")

    """ 

        We generate 50 encryption oracles to be tested. Generate the random 
        oracle, return the mode and oracle used. Guess the mode used with
        detect() function. 

        Print out the mode used, _mode, and the guess for each iteration of the
        loop. If there's even one case of the mode being not equal to the guess,
        raise an exception. 

        We're gonna enumerate all 50 tests for fun. 

    """

